DOSSEG
.MODEL TINY
.STACK 100h
.DATA
  a db 1,33,13,41,56,112,45,32,42,66
  b db 10 dup(0) 

.CODE
start:

  mov ax, @data
  mov ds, ax ; инициализация сегментов
  mov es, ax

  mov cx, 10
  lea si, a ; перенос данных из массива а в массив b
  lea di, b
  cld
  rep movsb

  mov cx, 10
  mov bx, 10 ; закидываем в bx 10 для дальнейшего деления
  lea si, b ; загружаем b в si

p1:
  
  mov ax, [si]
  mov ah, 00h ; обнуление верхнего байта ax
  mov dx, 0000h ; обнуление нижнего байта ax

p2:
  
  inc dl ; увеличение dl на 1
  div bl ; ax делим на bl (10) -> результат в al, а остаток в ah (122 -> al = 12; ah = 2)
  cmp al, 0 ; сравнение al (результат деления после пред строчки (12) ) и нуля
  push ax ; сохраняем значение ax
  mov ah, 00h ; обнуляем ah
  jne p2 ; если al не равно 0 => переходим к p2 и повторяем деление (jne - jump if not equal (прыг-скок если не равно). если равно, то без прыг-скок)

p3:
  
  pop ax ; берем значение из ax
  push dx ; сохраняем dx
  mov dl, ah ; загружаем в dl ah (остаток от деления)

  add dl, '0'
  mov ah, 2h ; преобразование в аски и вывод символа
  int 21h

  pop dx ; восстановление значения dx
  dec dl ; уменьшаем dl на 1
  cmp dl, 0 ; сравниваем с нулем
  jne p3 ; если dl != 0 => повторяем
  
  mov dl, ' '
  mov ah, 2h ; вывод пробела
  int 21h

  inc si ; переход к след элементу массива b 
  loop p1 ; уменьшаем cx и повторяем для след элемента массива
  
; ---------------------------------------  

  mov ax, 4C00H ; завершение программы
  int 21h
  
; вот есть число 122
; первое деление: делим 122 на 10. результат 12 остаток 2
; сейвим остаток и идем дальше
; второе деление: делим 12 на 10. результат 1 остаток 2
; сейвим остаток и идем дальше
; третье деление: делим 1 на 10. результат 0 остаток 1
; сейвим остаток
; выводим каждый остаток получается 1 2 2
; преобразуем каждый "вытаскиваемый" остаток в аски и выводим: 122

; получается делим пока остаток не будет 0. остаток от каждого деления закидываем в стек (первый пришел - последний ушел (спасибо ВА =) )).
; после вытаскиваем остатки в обратном порядке -> потом преобразовываем и выводим друг за другом
; ну и так для каждого элемента массива, двигаясь по нему

END start