#include <iostream>

int main()
{
	float a = 1.5;
	float b = 3;
	float c = 5;
	float sum = 0;

	__asm
	{
		finit // Инициализация FPU
		fld a // помещаем число наверх стека.
		fld b
		fld c
		fadd // сложить два числа из верха стека и положить результат в верх
		fadd // ..
		fstp sum // извлечь число из верха стека и положить в операнд. Копировать значение из регистра ST в sum
		// sum = (b + c) + a
	}
	std::cout << "first sum = " << sum << "\n";

	// 2. Нужно получить NaN.

	__asm
	{
		finit
		fstp sum
	}
	std::cout << "second sum = " << sum << "\n"; // потому, что после выполнения fstp число из стека пропадает. То есть мы вытащили хрен пойми что



	int ctrl = 0x027A; // 0x027B - флаг контроля. Если он не будет fldcw, то деление на ноль выдаст inf. С ним - исключение.
	a = 5;			   // Исключение можно обработать, но мне невероятно лень это делать. 
	b = 0;			   // Это число - "набор флагов" и в нем включен флаг деления на ноль.

	// ctrl - регистр с 16 битами. В нем содержится 16 флагов, которые относятся к различным прерываниям. 
	// 0000 0010 0111 1011. Это так же работает с 027A, но не работает с 027F

	__asm
	{
		finit
		fldcw ctrl // Маска деления на ноль включена
		fld a
		fld b
		fdiv
		fstp sum
	}
	std::cout << "third sum = " << sum << "\n";

}