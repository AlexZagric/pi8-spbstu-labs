#Обработка исключений

try-cath-throw-throws-finally

##1
try {
  код
} catch (...) {
  обработка
} finally {
  исполняется всегда 99.9%. независимо от исхода (была ошибка или нет)
  при system.exit() - не выполняется
}

##2
try {
  код
} catch (...) { что можем ловить (есть отдельная иерархия исключений):
  обработка
}

исключения делятся на два типа: провер и нет. проверяются компилятором

interface Throwable -> Error and Exception

Exception: RuntimeException (и его насл не относятся к провер искл.)

способы обработки: try-catch или обработка ошибки выше.

void foo() throws ... - внутри метода можно ничего не обр., но в месте, где вызывается такой метод - надо его обработать. обработать
в месте вывода или прокинут опять дальше

try {
  код
} catch (что-то тут) {
  throw new IOException; - кидаем на уровень выше -> должны обработать в месте вызова
}


##кетчей много бывает

try {
  код
} catch (что-то тут) {
  throw new IOException; - кидаем на уровень выше -> должны обработать в месте вызова
} catch () { при такой раст надо учитывать иерархию, иначе может не дойти до нужного

} catch (IOException | AithmeticException) { - чтобы не плодить одинаковые catch
  e.printStackTrace(); - так никто не делает.
}


try(FileReader r = ...) { -- try с ресурсами. тут получается автоматическое закрытие (autoclosable).
если надо что-то закрыть - делаем так

} catch (IOException e) {

}

способ получить МИНУС балл:
public static void main(String[] args) throws Exception - это минус 10 баллов

задание:
вывести файл в след формате:
игрок1: %player-name% - игрок2:%player2-name%
партия

результат: из файла

ошибки в лог файл
